# **pyGEMS** - 1D

This code is intended to be a sort of low-fidelity Python port of the General Mesh and Equations Solver (**GEMS**). Whereas **GEMS** is capable of computing high-fidelity simulations of 2D/3D reacting flows with enormous libraries for flame modeling, **pyGEMS** is intended for simulating one-dimensional reacting flows with simple global reaction mechanisms. **GEMS** was originally developed by Guoping Xia at Purdue University, and has since been expanded drastically by researchers from Purdue University, the University of Michigan, Ann Arbor, and the Air Force Research Laboratory. The hope is that this code might serve as a useful testbed for reduced-order model (ROM) developers to analyze performance of new ROM methods for reacting flow simulations, a field of research which poses significant difficulties in effective model-order reduction. 

## Documentation

A very brief introduction to running **pyGEMS** is included below. However, a PDF file containing much more detailed documentation for **pyGEMS** is included in `doc/`. This contains some theory regarding the governing equations, spatial discretization, and temporal discretization of the dynamical system. The various ROM methods which are currently implemented are also explained. Tables of the various input parameters, their required data types, and default values (where applicable), are included as well. This documentation will be continuously updated as new features are added.

## Installing dependencies

Only `numpy`, `scipy`, and `matplotlib` are required for executing **pyGEMS**. It is only tested for Python 3.7. You can install the dependencies manually, or use the `setup.py` installer (which will guarantee that the minimum package version number requirements are met):

```
python setup.py install
```

## Input Files

Four input files are required compute full-order model (FOM) solutions: `solverParams.inp`, a chemistry file, a mesh file, and an initial conditions file. The `solverParams.inp` file, chemistry file, and mesh file are simple text files written by the user. The possible formats of the initial condition file are explained later. A brief explanation of each if given below:

1. **`solverParams.inp`**: This file **must** have this name, and **must** be placed in the working directory. This file defines solver (e.g. spatial/temporal discretization), unsteady output, and visualization parameters.
2. **Chemistry file**: This file can be placed anywhere and referenced in the `gasFile` parameter in `solverParams.inp`. This defines the calorically-perfect gas properties of the chemical species which are included in the system, and the Arrhenius rate parameters which govern the global reactions.
3. **Mesh file**: This file can be placed anywhere and referenced in the `meshFile` parameter in `solverParams.inp`. As of the writing of this, **pyGEMS** can only handle uniform meshes, and this file simply defines the left and right boundary coordinates and the number of finite volume cells in the discretized domain.
4. **Initial conditions file**: Placement of this file depends on its format and is explained in more detail below. This file defines the primitive field from which an unsteady simulation is initialized.

 Input parameters from text input files are read by regular expressions; all must be formatted as `inputName = inputValue`, with as much white space before and after the `=` as desired. Lists should be enclosed by brackets (e.g. [val1, val2, val3]), and lists of lists should be formatted in kind (e.g. [[val11, val12],[val21, val22]]). Even if a list input only has one entry, it should be formatted as a list in the input file.

Initial condition files take one of three forms: 

1. A text file defining uniform "left" and "right" primitive states (pressure, velocity, temperature, and species mass fraction). Formatting of the parameters follows the same formatting rules for the previous text input files. This 
2. A NumPy `*.npy` binary file containing an array of the primitive variable fields. 
3. A restart file previously generated by **pyGEMS**. In `solverParams.inp`, setting the parameter `saveRestarts = True` will generate 



Please see the documentation in `doc/` for detailed explanations of all possible input parameters.

## Running **pyGEMS** 

**pyGEMS** is executed from the `src/driver.py` script, followed by a command line string argument containing the working directory. For example, 

```
python src/driver.py "~/path/to/working/directory"
```

## Outputs

Upon executing **pyGEMS**, several directories will be generated in the working directory:

1. **`UnsteadyFieldResults/`**:
2. **`ProbeResults/`**:
3. **`ImageResults/`**:
4. **`RestartFiles/`**:

## Sample Cases

Three sample cases are included in `caseFiles/`:

1. **`standingFlame_forced`**: Arguable the simplest reacting flow simulation, featuring a premixed flame with single-frequency outlet pressure forcing. The small mean-flow velocity is very closely balanced with the reaction-diffusion of the flame, leading to a largely-stationary with very simple system acoustics.
2. **`advectingFlame`**: A much more complex case for ROM development, featuring a premixed flame traveling downstream. There are no significant system acoustics, but the transient nature poses a challenge for future-state prediction.
3. **`advectingFlame_forced`**: The same initial condition profile as `advectingFlame`, with the addition of single-frequency outlet pressure forcing. This case presents some interesting, highly nonlinear thermoacoustic interactions that can be extremely challenging for traditional linear subspace ROMs to handle.

Running one of these cases out-of-the-box is as simple as, e.g.,

```
python src/driver.py "./caseFiles/standingFlame_forced"
```

## Utilities

Some very simple pre/post-processing scripts are provided in `utils/`. These include scripts for generating POD basis modes, calculating input parameters for non-reflective boundary conditions, plotting the power spectral density of a pressure probe signal, etc. Brief descriptions of the scripts and their input parameters are given within the scripts. More detailed explanations are provided in `doc/`.